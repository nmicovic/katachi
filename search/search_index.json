{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Katachi","text":"<p>Katachi is a Python package for validating, processing, and parsing directory structures against defined schemas.</p> <p>!!! warning \"Work in Progress\"     Katachi is currently under active development and should be considered a work in progress. APIs may change in future releases.</p>"},{"location":"#overview","title":"Overview","text":"<p>Katachi helps you define, validate, and process structured directory trees. It's particularly useful for:</p> <ul> <li>Data validation: Ensure datasets follow a consistent structure</li> <li>Processing pipelines: Process files based on their position in a directory tree</li> <li>Schema enforcement: Validate project structures against conventions</li> <li>Relationship validation: Verify relationships between files (like paired files)</li> </ul>"},{"location":"#features","title":"Features","text":"<ul> <li>\ud83d\udcd0 Schema-based validation - Define expected directory structures using YAML</li> <li>\ud83e\udde9 Extensible architecture - Create custom validators and actions</li> <li>\ud83d\udd04 Relationship validation - Validate relationships between files</li> <li>\ud83d\ude80 Command-line interface - Easy to use CLI with rich formatting</li> <li>\ud83d\udccb Detailed reports - Get comprehensive validation reports</li> </ul>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install katachi\n</code></pre>"},{"location":"#quick-start","title":"Quick Start","text":""},{"location":"#1-define-a-schema-schemayaml","title":"1. Define a schema (schema.yaml)","text":"<pre><code>semantical_name: data\ntype: directory\npattern_name: data\nchildren:\n  - semantical_name: image\n    pattern_name: \"img\\\\d+\"\n    type: file\n    extension: .jpg\n    description: \"Image files with numeric identifiers\"\n  - semantical_name: metadata\n    pattern_name: \"img\\\\d+\"\n    type: file\n    extension: .json\n    description: \"Metadata for image files\"\n  - semantical_name: file_pairs_check\n    type: predicate\n    predicate_type: pair_comparison\n    description: \"Check if images have matching metadata files\"\n    elements:\n      - image\n      - metadata\n</code></pre>"},{"location":"#2-validate-a-directory-structure","title":"2. Validate a directory structure","text":"<pre><code>katachi validate schema.yaml target_directory\n</code></pre>"},{"location":"#3-process-the-results","title":"3. Process the results","text":"<pre><code>\u2705 Validation passed!\n  - Found 2 image files\n  - All image files have matching metadata files\n</code></pre>"},{"location":"#next-steps","title":"Next Steps","text":"<ul> <li>Read the API documentation to learn about the available modules</li> <li>Explore examples to see more use cases</li> <li>Learn how to extend Katachi with custom validators and actions</li> </ul>"},{"location":"modules/","title":"Katachi API Reference","text":"<p>Katachi is a Python package for validating, processing, and parsing directory structures against defined schemas.</p>"},{"location":"modules/#core-concepts","title":"Core Concepts","text":""},{"location":"modules/#schema-nodes","title":"Schema Nodes","text":"<p>Schema nodes represent the elements in your directory structure:</p> <ul> <li>SchemaNode: Abstract base class for all schema elements</li> <li>SchemaDirectory: Represents a directory in the schema</li> <li>SchemaFile: Represents a file in the schema</li> <li>SchemaPredicateNode: Represents a validation rule between elements</li> </ul>"},{"location":"modules/#two-phase-validation","title":"Two-Phase Validation","text":"<p>Katachi uses a two-phase validation approach:</p> <ol> <li>Structural Validation: Validates the existence and properties of files and directories</li> <li>Predicate Evaluation: Validates relationships between elements that passed structural validation</li> </ol>"},{"location":"modules/#modules","title":"Modules","text":""},{"location":"modules/#schema-node-katachischemaschema_node","title":"Schema Node (<code>katachi.schema.schema_node</code>)","text":"<p>The foundation of Katachi is the schema node system, which defines how directory structures should be organized.</p> <pre><code>from katachi.schema.schema_node import SchemaDirectory, SchemaFile, SchemaPredicateNode\nfrom pathlib import Path\n\n# Create a schema hierarchy\nroot = SchemaDirectory(path=Path(\"data\"), semantical_name=\"data\", description=\"Data directory\")\n\n# Add file templates\nroot.add_child(SchemaFile(\n    path=Path(\"data/image.jpg\"),\n    semantical_name=\"image\",\n    extension=\".jpg\",\n    pattern_validation=r\"img\\d+\"\n))\n\nroot.add_child(SchemaFile(\n    path=Path(\"data/metadata.json\"),\n    semantical_name=\"metadata\",\n    extension=\".json\",\n    pattern_validation=r\"img\\d+\"\n))\n\n# Add a predicate to validate relationships\nroot.add_child(SchemaPredicateNode(\n    path=Path(\"data\"),\n    semantical_name=\"file_pairs_check\",\n    predicate_type=\"pair_comparison\",\n    elements=[\"image\", \"metadata\"],\n    description=\"Check if images have corresponding metadata files\"\n))\n</code></pre>"},{"location":"modules/#katachi.schema.schema_node.SchemaDirectory","title":"<code>SchemaDirectory</code>","text":"<p>               Bases: <code>SchemaNode</code></p> <p>Represents a directory in the schema. Can contain children nodes (files or other directories).</p> Source code in <code>src/katachi/schema/schema_node.py</code> <pre><code>class SchemaDirectory(SchemaNode):\n    \"\"\"\n    Represents a directory in the schema.\n    Can contain children nodes (files or other directories).\n    \"\"\"\n\n    def __init__(\n        self,\n        path: Path,\n        semantical_name: str,\n        description: Optional[str] = None,\n        pattern_validation: Optional[str] = None,\n        metadata: Optional[dict[str, Any]] = None,\n    ):\n        \"\"\"\n        Initialize a schema directory node.\n\n        Args:\n            path: Path to this directory\n            semantical_name: The semantic name of this directory in the schema\n            description: Optional description of the directory\n            pattern_validation: Optional regex pattern for name validation\n            metadata: Optional metadata for custom validations\n        \"\"\"\n        super().__init__(path, semantical_name, description, pattern_validation, metadata)\n        self.children: list[SchemaNode] = []\n\n    def get_type(self) -&gt; str:\n        return \"directory\"\n\n    def add_child(self, child: SchemaNode) -&gt; None:\n        \"\"\"\n        Add a child node to this directory.\n\n        Args:\n            child: The child node (file or directory) to add\n        \"\"\"\n        self.children.append(child)\n\n    def get_child_by_name(self, name: str) -&gt; Optional[SchemaNode]:\n        \"\"\"\n        Get a child node by its semantical name.\n\n        Args:\n            name: The semantical name of the child to find\n\n        Returns:\n            The child node if found, None otherwise\n        \"\"\"\n        for child in self.children:\n            if child.semantical_name == name:\n                return child\n        return None\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Detailed string representation of the directory node.\"\"\"\n        return f\"{self.__class__.__name__}(path='{self.path}', semantical_name='{self.semantical_name}', children={len(self.children)})\"\n</code></pre>"},{"location":"modules/#katachi.schema.schema_node.SchemaDirectory.__init__","title":"<code>__init__(path, semantical_name, description=None, pattern_validation=None, metadata=None)</code>","text":"<p>Initialize a schema directory node.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>Path to this directory</p> required <code>semantical_name</code> <code>str</code> <p>The semantic name of this directory in the schema</p> required <code>description</code> <code>Optional[str]</code> <p>Optional description of the directory</p> <code>None</code> <code>pattern_validation</code> <code>Optional[str]</code> <p>Optional regex pattern for name validation</p> <code>None</code> <code>metadata</code> <code>Optional[dict[str, Any]]</code> <p>Optional metadata for custom validations</p> <code>None</code> Source code in <code>src/katachi/schema/schema_node.py</code> <pre><code>def __init__(\n    self,\n    path: Path,\n    semantical_name: str,\n    description: Optional[str] = None,\n    pattern_validation: Optional[str] = None,\n    metadata: Optional[dict[str, Any]] = None,\n):\n    \"\"\"\n    Initialize a schema directory node.\n\n    Args:\n        path: Path to this directory\n        semantical_name: The semantic name of this directory in the schema\n        description: Optional description of the directory\n        pattern_validation: Optional regex pattern for name validation\n        metadata: Optional metadata for custom validations\n    \"\"\"\n    super().__init__(path, semantical_name, description, pattern_validation, metadata)\n    self.children: list[SchemaNode] = []\n</code></pre>"},{"location":"modules/#katachi.schema.schema_node.SchemaDirectory.__repr__","title":"<code>__repr__()</code>","text":"<p>Detailed string representation of the directory node.</p> Source code in <code>src/katachi/schema/schema_node.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Detailed string representation of the directory node.\"\"\"\n    return f\"{self.__class__.__name__}(path='{self.path}', semantical_name='{self.semantical_name}', children={len(self.children)})\"\n</code></pre>"},{"location":"modules/#katachi.schema.schema_node.SchemaDirectory.add_child","title":"<code>add_child(child)</code>","text":"<p>Add a child node to this directory.</p> <p>Parameters:</p> Name Type Description Default <code>child</code> <code>SchemaNode</code> <p>The child node (file or directory) to add</p> required Source code in <code>src/katachi/schema/schema_node.py</code> <pre><code>def add_child(self, child: SchemaNode) -&gt; None:\n    \"\"\"\n    Add a child node to this directory.\n\n    Args:\n        child: The child node (file or directory) to add\n    \"\"\"\n    self.children.append(child)\n</code></pre>"},{"location":"modules/#katachi.schema.schema_node.SchemaDirectory.get_child_by_name","title":"<code>get_child_by_name(name)</code>","text":"<p>Get a child node by its semantical name.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The semantical name of the child to find</p> required <p>Returns:</p> Type Description <code>Optional[SchemaNode]</code> <p>The child node if found, None otherwise</p> Source code in <code>src/katachi/schema/schema_node.py</code> <pre><code>def get_child_by_name(self, name: str) -&gt; Optional[SchemaNode]:\n    \"\"\"\n    Get a child node by its semantical name.\n\n    Args:\n        name: The semantical name of the child to find\n\n    Returns:\n        The child node if found, None otherwise\n    \"\"\"\n    for child in self.children:\n        if child.semantical_name == name:\n            return child\n    return None\n</code></pre>"},{"location":"modules/#katachi.schema.schema_node.SchemaFile","title":"<code>SchemaFile</code>","text":"<p>               Bases: <code>SchemaNode</code></p> <p>Represents a file in the schema.</p> Source code in <code>src/katachi/schema/schema_node.py</code> <pre><code>class SchemaFile(SchemaNode):\n    \"\"\"\n    Represents a file in the schema.\n    \"\"\"\n\n    def __init__(\n        self,\n        path: Path,\n        semantical_name: str,\n        extension: str,\n        description: Optional[str] = None,\n        pattern_validation: Optional[str] = None,\n        metadata: Optional[dict[str, Any]] = None,\n    ):\n        \"\"\"\n        Initialize a schema file node.\n\n        Args:\n            path: Path to this file\n            semantical_name: The semantic name of this file in the schema\n            extension: The file extension\n            description: Optional description of the file\n            pattern_validation: Optional regex pattern for name validation\n            metadata: Optional metadata for custom validations\n        \"\"\"\n        super().__init__(path, semantical_name, description, pattern_validation, metadata)\n        self.extension: str = extension\n\n    def get_type(self) -&gt; str:\n        return \"file\"\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Detailed string representation of the file node.\"\"\"\n        return f\"{self.__class__.__name__}(path='{self.path}', semantical_name='{self.semantical_name}', extension='{self.extension}')\"\n</code></pre>"},{"location":"modules/#katachi.schema.schema_node.SchemaFile.__init__","title":"<code>__init__(path, semantical_name, extension, description=None, pattern_validation=None, metadata=None)</code>","text":"<p>Initialize a schema file node.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>Path to this file</p> required <code>semantical_name</code> <code>str</code> <p>The semantic name of this file in the schema</p> required <code>extension</code> <code>str</code> <p>The file extension</p> required <code>description</code> <code>Optional[str]</code> <p>Optional description of the file</p> <code>None</code> <code>pattern_validation</code> <code>Optional[str]</code> <p>Optional regex pattern for name validation</p> <code>None</code> <code>metadata</code> <code>Optional[dict[str, Any]]</code> <p>Optional metadata for custom validations</p> <code>None</code> Source code in <code>src/katachi/schema/schema_node.py</code> <pre><code>def __init__(\n    self,\n    path: Path,\n    semantical_name: str,\n    extension: str,\n    description: Optional[str] = None,\n    pattern_validation: Optional[str] = None,\n    metadata: Optional[dict[str, Any]] = None,\n):\n    \"\"\"\n    Initialize a schema file node.\n\n    Args:\n        path: Path to this file\n        semantical_name: The semantic name of this file in the schema\n        extension: The file extension\n        description: Optional description of the file\n        pattern_validation: Optional regex pattern for name validation\n        metadata: Optional metadata for custom validations\n    \"\"\"\n    super().__init__(path, semantical_name, description, pattern_validation, metadata)\n    self.extension: str = extension\n</code></pre>"},{"location":"modules/#katachi.schema.schema_node.SchemaFile.__repr__","title":"<code>__repr__()</code>","text":"<p>Detailed string representation of the file node.</p> Source code in <code>src/katachi/schema/schema_node.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Detailed string representation of the file node.\"\"\"\n    return f\"{self.__class__.__name__}(path='{self.path}', semantical_name='{self.semantical_name}', extension='{self.extension}')\"\n</code></pre>"},{"location":"modules/#katachi.schema.schema_node.SchemaNode","title":"<code>SchemaNode</code>","text":"<p>               Bases: <code>ABC</code></p> <p>Base abstract class for all schema nodes.</p> <p>SchemaNode represents any node in the file/directory structure schema. It contains common properties and methods that all nodes should implement.</p> Source code in <code>src/katachi/schema/schema_node.py</code> <pre><code>class SchemaNode(ABC):\n    \"\"\"\n    Base abstract class for all schema nodes.\n\n    SchemaNode represents any node in the file/directory structure schema.\n    It contains common properties and methods that all nodes should implement.\n    \"\"\"\n\n    def __init__(\n        self,\n        path: Path,\n        semantical_name: str,\n        description: Optional[str] = None,\n        pattern_validation: Optional[str] = None,\n        metadata: Optional[dict[str, Any]] = None,\n    ):\n        \"\"\"\n        Initialize a schema node.\n\n        Args:\n            path: Path to this node\n            semantical_name: The semantic name of this node in the schema\n            description: Optional description of the node\n            pattern_validation: Optional regex pattern for name validation\n            metadata: Optional metadata for custom validations\n        \"\"\"\n        self.path: Path = path\n        self.semantical_name: str = semantical_name\n        self.description: Optional[str] = description\n        self.pattern_validation: Optional[Pattern] = None\n        self.metadata: dict[str, Any] = metadata or {}\n\n        if pattern_validation:\n            self.pattern_validation = re_compile(pattern_validation)\n\n    @abstractmethod\n    def get_type(self) -&gt; str:\n        \"\"\"\n        Get the type of this node.\n\n        Returns:\n            String representing the node type (\"file\" or \"directory\").\n        \"\"\"\n        pass\n\n    def __str__(self) -&gt; str:\n        \"\"\"String representation of the node.\"\"\"\n        return f\"{self.get_type()}: {self.semantical_name} at {self.path}\"\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Detailed string representation of the node.\"\"\"\n        return f\"{self.__class__.__name__}(path='{self.path}', semantical_name='{self.semantical_name}')\"\n</code></pre>"},{"location":"modules/#katachi.schema.schema_node.SchemaNode.__init__","title":"<code>__init__(path, semantical_name, description=None, pattern_validation=None, metadata=None)</code>","text":"<p>Initialize a schema node.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>Path to this node</p> required <code>semantical_name</code> <code>str</code> <p>The semantic name of this node in the schema</p> required <code>description</code> <code>Optional[str]</code> <p>Optional description of the node</p> <code>None</code> <code>pattern_validation</code> <code>Optional[str]</code> <p>Optional regex pattern for name validation</p> <code>None</code> <code>metadata</code> <code>Optional[dict[str, Any]]</code> <p>Optional metadata for custom validations</p> <code>None</code> Source code in <code>src/katachi/schema/schema_node.py</code> <pre><code>def __init__(\n    self,\n    path: Path,\n    semantical_name: str,\n    description: Optional[str] = None,\n    pattern_validation: Optional[str] = None,\n    metadata: Optional[dict[str, Any]] = None,\n):\n    \"\"\"\n    Initialize a schema node.\n\n    Args:\n        path: Path to this node\n        semantical_name: The semantic name of this node in the schema\n        description: Optional description of the node\n        pattern_validation: Optional regex pattern for name validation\n        metadata: Optional metadata for custom validations\n    \"\"\"\n    self.path: Path = path\n    self.semantical_name: str = semantical_name\n    self.description: Optional[str] = description\n    self.pattern_validation: Optional[Pattern] = None\n    self.metadata: dict[str, Any] = metadata or {}\n\n    if pattern_validation:\n        self.pattern_validation = re_compile(pattern_validation)\n</code></pre>"},{"location":"modules/#katachi.schema.schema_node.SchemaNode.__repr__","title":"<code>__repr__()</code>","text":"<p>Detailed string representation of the node.</p> Source code in <code>src/katachi/schema/schema_node.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Detailed string representation of the node.\"\"\"\n    return f\"{self.__class__.__name__}(path='{self.path}', semantical_name='{self.semantical_name}')\"\n</code></pre>"},{"location":"modules/#katachi.schema.schema_node.SchemaNode.__str__","title":"<code>__str__()</code>","text":"<p>String representation of the node.</p> Source code in <code>src/katachi/schema/schema_node.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"String representation of the node.\"\"\"\n    return f\"{self.get_type()}: {self.semantical_name} at {self.path}\"\n</code></pre>"},{"location":"modules/#katachi.schema.schema_node.SchemaNode.get_type","title":"<code>get_type()</code>  <code>abstractmethod</code>","text":"<p>Get the type of this node.</p> <p>Returns:</p> Type Description <code>str</code> <p>String representing the node type (\"file\" or \"directory\").</p> Source code in <code>src/katachi/schema/schema_node.py</code> <pre><code>@abstractmethod\ndef get_type(self) -&gt; str:\n    \"\"\"\n    Get the type of this node.\n\n    Returns:\n        String representing the node type (\"file\" or \"directory\").\n    \"\"\"\n    pass\n</code></pre>"},{"location":"modules/#katachi.schema.schema_node.SchemaPredicateNode","title":"<code>SchemaPredicateNode</code>","text":"<p>               Bases: <code>SchemaNode</code></p> <p>Represents a predicate node in the schema. Used for validating relationships between other schema nodes.</p> Source code in <code>src/katachi/schema/schema_node.py</code> <pre><code>class SchemaPredicateNode(SchemaNode):\n    \"\"\"\n    Represents a predicate node in the schema.\n    Used for validating relationships between other schema nodes.\n    \"\"\"\n\n    def __init__(\n        self,\n        path: Path,\n        semantical_name: str,\n        predicate_type: str,\n        elements: list[str],\n        description: Optional[str] = None,\n        metadata: Optional[dict[str, Any]] = None,\n    ):\n        \"\"\"\n        Initialize a schema predicate node.\n\n        Args:\n            path: Path to this node\n            semantical_name: The semantic name of this node in the schema\n            predicate_type: Type of predicate (e.g., 'pair_comparison')\n            elements: List of semantical names of nodes this predicate operates on\n            description: Optional description of the predicate\n            metadata: Optional metadata for custom validations\n        \"\"\"\n        super().__init__(path, semantical_name, description, None, metadata)\n        self.predicate_type: str = predicate_type\n        self.elements: list[str] = elements\n\n    def get_type(self) -&gt; str:\n        return \"predicate\"\n\n    def __repr__(self) -&gt; str:\n        \"\"\"Detailed string representation of the predicate node.\"\"\"\n        return (\n            f\"{self.__class__.__name__}(path='{self.path}', \"\n            f\"semantical_name='{self.semantical_name}', \"\n            f\"predicate_type='{self.predicate_type}', \"\n            f\"elements={self.elements})\"\n        )\n</code></pre>"},{"location":"modules/#katachi.schema.schema_node.SchemaPredicateNode.__init__","title":"<code>__init__(path, semantical_name, predicate_type, elements, description=None, metadata=None)</code>","text":"<p>Initialize a schema predicate node.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>Path to this node</p> required <code>semantical_name</code> <code>str</code> <p>The semantic name of this node in the schema</p> required <code>predicate_type</code> <code>str</code> <p>Type of predicate (e.g., 'pair_comparison')</p> required <code>elements</code> <code>list[str]</code> <p>List of semantical names of nodes this predicate operates on</p> required <code>description</code> <code>Optional[str]</code> <p>Optional description of the predicate</p> <code>None</code> <code>metadata</code> <code>Optional[dict[str, Any]]</code> <p>Optional metadata for custom validations</p> <code>None</code> Source code in <code>src/katachi/schema/schema_node.py</code> <pre><code>def __init__(\n    self,\n    path: Path,\n    semantical_name: str,\n    predicate_type: str,\n    elements: list[str],\n    description: Optional[str] = None,\n    metadata: Optional[dict[str, Any]] = None,\n):\n    \"\"\"\n    Initialize a schema predicate node.\n\n    Args:\n        path: Path to this node\n        semantical_name: The semantic name of this node in the schema\n        predicate_type: Type of predicate (e.g., 'pair_comparison')\n        elements: List of semantical names of nodes this predicate operates on\n        description: Optional description of the predicate\n        metadata: Optional metadata for custom validations\n    \"\"\"\n    super().__init__(path, semantical_name, description, None, metadata)\n    self.predicate_type: str = predicate_type\n    self.elements: list[str] = elements\n</code></pre>"},{"location":"modules/#katachi.schema.schema_node.SchemaPredicateNode.__repr__","title":"<code>__repr__()</code>","text":"<p>Detailed string representation of the predicate node.</p> Source code in <code>src/katachi/schema/schema_node.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"Detailed string representation of the predicate node.\"\"\"\n    return (\n        f\"{self.__class__.__name__}(path='{self.path}', \"\n        f\"semantical_name='{self.semantical_name}', \"\n        f\"predicate_type='{self.predicate_type}', \"\n        f\"elements={self.elements})\"\n    )\n</code></pre>"},{"location":"modules/#schema-importer-katachischemaimporter","title":"Schema Importer (<code>katachi.schema.importer</code>)","text":"<p>Load schema definitions from YAML files to create SchemaNode structures.</p> <pre><code>from katachi.schema.importer import load_yaml\nfrom pathlib import Path\n\n# Load schema from YAML file\nschema = load_yaml(Path(\"schema.yaml\"), Path(\"target_directory\"))\n\n# Now schema contains a fully constructed schema hierarchy\nif schema:\n    print(f\"Loaded schema for {schema.semantical_name}\")\nelse:\n    print(\"Failed to load schema\")\n</code></pre>"},{"location":"modules/#katachi.schema.importer.load_yaml","title":"<code>load_yaml(schema_path, target_path)</code>","text":"<p>Load a YAML schema file and return a SchemaNode tree structure.</p> <p>Parameters:</p> Name Type Description Default <code>schema_path</code> <code>Path</code> <p>Path to the YAML schema file</p> required <code>target_path</code> <code>Path</code> <p>Path to the directory that will be validated against the schema</p> required <p>Returns:</p> Type Description <code>Optional[SchemaNode]</code> <p>The root SchemaNode representing the schema hierarchy</p> <p>Raises:</p> Type Description <code>SchemaFileNotFoundError</code> <p>If the schema file does not exist</p> <code>EmptySchemaFileError</code> <p>If the schema file is empty</p> <code>InvalidYAMLContentError</code> <p>If the YAML content cannot be parsed</p> <code>FailedToLoadYAMLFileError</code> <p>If there are other errors loading the YAML file</p> Source code in <code>src/katachi/schema/importer.py</code> <pre><code>def load_yaml(schema_path: Path, target_path: Path) -&gt; Optional[SchemaNode]:\n    \"\"\"\n    Load a YAML schema file and return a SchemaNode tree structure.\n\n    Args:\n        schema_path: Path to the YAML schema file\n        target_path: Path to the directory that will be validated against the schema\n\n    Returns:\n        The root SchemaNode representing the schema hierarchy\n\n    Raises:\n        SchemaFileNotFoundError: If the schema file does not exist\n        EmptySchemaFileError: If the schema file is empty\n        InvalidYAMLContentError: If the YAML content cannot be parsed\n        FailedToLoadYAMLFileError: If there are other errors loading the YAML file\n    \"\"\"\n    if not schema_path.exists():\n        logging.error(f\"Schema file not found: {schema_path}\")\n        return None\n\n    try:\n        with open(schema_path) as file:\n            file_content = file.read()\n            if not file_content.strip():\n                logging.error(f\"Schema file is empty: {schema_path}\")\n                return None\n\n            data = yaml.safe_load(file_content)\n            if data is None:\n                logging.error(f\"Invalid YAML content in file: {schema_path}\")\n                return None\n\n            # Important: For the root node, we use the target_path directly\n            # instead of constructing a path based on the schema node name\n            return _parse_node(data, target_path, is_root=True)\n    except yaml.YAMLError:\n        logging.exception(f\"Failed to load YAML file {schema_path}\")\n        return None\n    except Exception:\n        logging.exception(f\"An error occurred while loading the YAML file {schema_path}\")\n        return None\n</code></pre>"},{"location":"modules/#schema-validator-katachischemavalidate","title":"Schema Validator (<code>katachi.schema.validate</code>)","text":"<p>Validate directory structures against schema definitions.</p> <pre><code>from katachi.schema.validate import validate_schema, format_validation_results\nfrom pathlib import Path\n\n# Validate target directory against schema\nreport = validate_schema(schema, Path(\"directory_to_validate\"))\n\n# Check if validation was successful\nif report.is_valid():\n    print(\"Validation successful!\")\nelse:\n    # Print formatted validation results\n    print(format_validation_results(report))\n</code></pre> <p>Actions module for Katachi.</p> <p>This module provides functionality for registering and executing callbacks when traversing the file system according to a schema.</p>"},{"location":"modules/#katachi.schema.actions.ActionRegistration","title":"<code>ActionRegistration</code>  <code>dataclass</code>","text":"<p>Action registration details.</p> Source code in <code>src/katachi/schema/actions.py</code> <pre><code>@dataclass\nclass ActionRegistration:\n    \"\"\"Action registration details.\"\"\"\n\n    callback: ActionCallback\n    timing: ActionTiming\n    description: str\n</code></pre>"},{"location":"modules/#katachi.schema.actions.ActionRegistry","title":"<code>ActionRegistry</code>","text":"<p>Registry for file and directory actions.</p> Source code in <code>src/katachi/schema/actions.py</code> <pre><code>class ActionRegistry:\n    \"\"\"Registry for file and directory actions.\"\"\"\n\n    # Registry of callbacks by semantic name\n    _registry: ClassVar[dict[str, ActionRegistration]] = {}\n\n    @classmethod\n    def register(\n        cls,\n        semantical_name: str,\n        callback: ActionCallback,\n        timing: ActionTiming = ActionTiming.AFTER_VALIDATION,\n        description: str = \"\",\n    ) -&gt; None:\n        \"\"\"\n        Register a callback for a specific schema node semantic name.\n\n        Args:\n            semantical_name: The semantic name to trigger the callback for\n            callback: Function to call when traversing a node with this semantic name\n            timing: When the action should be executed\n            description: Human-readable description of what the action does\n        \"\"\"\n        cls._registry[semantical_name] = ActionRegistration(\n            callback=callback, timing=timing, description=description or f\"Action for {semantical_name}\"\n        )\n\n    @classmethod\n    def get(cls, semantical_name: str) -&gt; Optional[ActionRegistration]:\n        \"\"\"Get a registered action by semantical name.\"\"\"\n        return cls._registry.get(semantical_name)\n\n    @classmethod\n    def execute_actions(\n        cls,\n        registry: NodeRegistry,\n        context: Optional[dict[str, Any]] = None,\n        timing: ActionTiming = ActionTiming.AFTER_VALIDATION,\n    ) -&gt; list[ActionResult]:\n        \"\"\"\n        Execute all registered actions on validated nodes.\n\n        Args:\n            registry: Registry of validated nodes\n            context: Additional context data\n            timing: Which set of actions to execute based on timing\n\n        Returns:\n            List of action results\n        \"\"\"\n        results = []\n        context = context or {}\n\n        # Get all semantical names from the registry\n        for semantical_name, registration in cls._registry.items():\n            # Skip actions that don't match the requested timing\n            if registration.timing != timing:\n                continue\n\n            # Get all nodes with this semantical name\n            node_contexts = registry.get_nodes_by_name(semantical_name)\n            for node_ctx in node_contexts:\n                try:\n                    # Get parent contexts\n                    parent_contexts = []\n                    for parent_path in node_ctx.parent_paths:\n                        parent_node_ctx = registry.get_node_by_path(parent_path)\n                        if parent_node_ctx:\n                            parent_contexts.append((parent_node_ctx.node, parent_node_ctx.path))\n\n                    # Execute the action\n                    registration.callback(node_ctx.node, node_ctx.path, parent_contexts, context)\n                    results.append(\n                        ActionResult(\n                            success=True,\n                            message=f\"Executed {registration.description}\",\n                            path=node_ctx.path,\n                            action_name=semantical_name,\n                        )\n                    )\n                except Exception as e:\n                    results.append(\n                        ActionResult(\n                            success=False,\n                            message=f\"Action failed: {e!s}\",\n                            path=node_ctx.path,\n                            action_name=semantical_name,\n                        )\n                    )\n\n        return results\n</code></pre>"},{"location":"modules/#katachi.schema.actions.ActionRegistry.execute_actions","title":"<code>execute_actions(registry, context=None, timing=ActionTiming.AFTER_VALIDATION)</code>  <code>classmethod</code>","text":"<p>Execute all registered actions on validated nodes.</p> <p>Parameters:</p> Name Type Description Default <code>registry</code> <code>NodeRegistry</code> <p>Registry of validated nodes</p> required <code>context</code> <code>Optional[dict[str, Any]]</code> <p>Additional context data</p> <code>None</code> <code>timing</code> <code>ActionTiming</code> <p>Which set of actions to execute based on timing</p> <code>AFTER_VALIDATION</code> <p>Returns:</p> Type Description <code>list[ActionResult]</code> <p>List of action results</p> Source code in <code>src/katachi/schema/actions.py</code> <pre><code>@classmethod\ndef execute_actions(\n    cls,\n    registry: NodeRegistry,\n    context: Optional[dict[str, Any]] = None,\n    timing: ActionTiming = ActionTiming.AFTER_VALIDATION,\n) -&gt; list[ActionResult]:\n    \"\"\"\n    Execute all registered actions on validated nodes.\n\n    Args:\n        registry: Registry of validated nodes\n        context: Additional context data\n        timing: Which set of actions to execute based on timing\n\n    Returns:\n        List of action results\n    \"\"\"\n    results = []\n    context = context or {}\n\n    # Get all semantical names from the registry\n    for semantical_name, registration in cls._registry.items():\n        # Skip actions that don't match the requested timing\n        if registration.timing != timing:\n            continue\n\n        # Get all nodes with this semantical name\n        node_contexts = registry.get_nodes_by_name(semantical_name)\n        for node_ctx in node_contexts:\n            try:\n                # Get parent contexts\n                parent_contexts = []\n                for parent_path in node_ctx.parent_paths:\n                    parent_node_ctx = registry.get_node_by_path(parent_path)\n                    if parent_node_ctx:\n                        parent_contexts.append((parent_node_ctx.node, parent_node_ctx.path))\n\n                # Execute the action\n                registration.callback(node_ctx.node, node_ctx.path, parent_contexts, context)\n                results.append(\n                    ActionResult(\n                        success=True,\n                        message=f\"Executed {registration.description}\",\n                        path=node_ctx.path,\n                        action_name=semantical_name,\n                    )\n                )\n            except Exception as e:\n                results.append(\n                    ActionResult(\n                        success=False,\n                        message=f\"Action failed: {e!s}\",\n                        path=node_ctx.path,\n                        action_name=semantical_name,\n                    )\n                )\n\n    return results\n</code></pre>"},{"location":"modules/#katachi.schema.actions.ActionRegistry.get","title":"<code>get(semantical_name)</code>  <code>classmethod</code>","text":"<p>Get a registered action by semantical name.</p> Source code in <code>src/katachi/schema/actions.py</code> <pre><code>@classmethod\ndef get(cls, semantical_name: str) -&gt; Optional[ActionRegistration]:\n    \"\"\"Get a registered action by semantical name.\"\"\"\n    return cls._registry.get(semantical_name)\n</code></pre>"},{"location":"modules/#katachi.schema.actions.ActionRegistry.register","title":"<code>register(semantical_name, callback, timing=ActionTiming.AFTER_VALIDATION, description='')</code>  <code>classmethod</code>","text":"<p>Register a callback for a specific schema node semantic name.</p> <p>Parameters:</p> Name Type Description Default <code>semantical_name</code> <code>str</code> <p>The semantic name to trigger the callback for</p> required <code>callback</code> <code>ActionCallback</code> <p>Function to call when traversing a node with this semantic name</p> required <code>timing</code> <code>ActionTiming</code> <p>When the action should be executed</p> <code>AFTER_VALIDATION</code> <code>description</code> <code>str</code> <p>Human-readable description of what the action does</p> <code>''</code> Source code in <code>src/katachi/schema/actions.py</code> <pre><code>@classmethod\ndef register(\n    cls,\n    semantical_name: str,\n    callback: ActionCallback,\n    timing: ActionTiming = ActionTiming.AFTER_VALIDATION,\n    description: str = \"\",\n) -&gt; None:\n    \"\"\"\n    Register a callback for a specific schema node semantic name.\n\n    Args:\n        semantical_name: The semantic name to trigger the callback for\n        callback: Function to call when traversing a node with this semantic name\n        timing: When the action should be executed\n        description: Human-readable description of what the action does\n    \"\"\"\n    cls._registry[semantical_name] = ActionRegistration(\n        callback=callback, timing=timing, description=description or f\"Action for {semantical_name}\"\n    )\n</code></pre>"},{"location":"modules/#katachi.schema.actions.ActionResult","title":"<code>ActionResult</code>","text":"<p>Represents the result of an action execution.</p> Source code in <code>src/katachi/schema/actions.py</code> <pre><code>class ActionResult:\n    \"\"\"Represents the result of an action execution.\"\"\"\n\n    def __init__(self, success: bool, message: str, path: Path, action_name: str):\n        \"\"\"\n        Initialize an action result.\n\n        Args:\n            success: Whether the action succeeded\n            message: Description of what happened\n            path: The path the action was performed on\n            action_name: Name of the action that was performed\n        \"\"\"\n        self.success = success\n        self.message = message\n        self.path = path\n        self.action_name = action_name\n\n    def __str__(self) -&gt; str:\n        status = \"Success\" if self.success else \"Failed\"\n        return f\"{status} - {self.action_name} on {self.path}: {self.message}\"\n</code></pre>"},{"location":"modules/#katachi.schema.actions.ActionResult.__init__","title":"<code>__init__(success, message, path, action_name)</code>","text":"<p>Initialize an action result.</p> <p>Parameters:</p> Name Type Description Default <code>success</code> <code>bool</code> <p>Whether the action succeeded</p> required <code>message</code> <code>str</code> <p>Description of what happened</p> required <code>path</code> <code>Path</code> <p>The path the action was performed on</p> required <code>action_name</code> <code>str</code> <p>Name of the action that was performed</p> required Source code in <code>src/katachi/schema/actions.py</code> <pre><code>def __init__(self, success: bool, message: str, path: Path, action_name: str):\n    \"\"\"\n    Initialize an action result.\n\n    Args:\n        success: Whether the action succeeded\n        message: Description of what happened\n        path: The path the action was performed on\n        action_name: Name of the action that was performed\n    \"\"\"\n    self.success = success\n    self.message = message\n    self.path = path\n    self.action_name = action_name\n</code></pre>"},{"location":"modules/#katachi.schema.actions.ActionTiming","title":"<code>ActionTiming</code>","text":"<p>               Bases: <code>Enum</code></p> <p>When an action should be executed.</p> Source code in <code>src/katachi/schema/actions.py</code> <pre><code>class ActionTiming(Enum):\n    \"\"\"When an action should be executed.\"\"\"\n\n    DURING_VALIDATION = auto()  # Run during structure validation (old behavior)\n    AFTER_VALIDATION = auto()  # Run after all validation is complete (default new behavior)\n</code></pre>"},{"location":"modules/#katachi.schema.actions.process_node","title":"<code>process_node(node, path, parent_contexts, context=None)</code>","text":"<p>Process a node by running any registered callbacks for it.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>SchemaNode</code> <p>Current schema node being processed</p> required <code>path</code> <code>Path</code> <p>Path being validated</p> required <code>parent_contexts</code> <code>list[NodeContext]</code> <p>List of parent (node, path) tuples</p> required <code>context</code> <code>Optional[dict[str, Any]]</code> <p>Additional context data</p> <code>None</code> Source code in <code>src/katachi/schema/actions.py</code> <pre><code>def process_node(\n    node: SchemaNode,\n    path: Path,\n    parent_contexts: list[NodeContext],\n    context: Optional[dict[str, Any]] = None,\n) -&gt; None:\n    \"\"\"\n    Process a node by running any registered callbacks for it.\n\n    Args:\n        node: Current schema node being processed\n        path: Path being validated\n        parent_contexts: List of parent (node, path) tuples\n        context: Additional context data\n    \"\"\"\n    context = context or {}\n\n    # Check if there's a callback registered for this node's semantic name\n    registration = ActionRegistry.get(node.semantical_name)\n    if registration and registration.timing == ActionTiming.DURING_VALIDATION:\n        registration.callback(node, path, parent_contexts, context)\n</code></pre>"},{"location":"modules/#katachi.schema.actions.register_action","title":"<code>register_action(semantical_name, callback)</code>","text":"<p>Register a callback for a specific schema node semantic name.</p> <p>Parameters:</p> Name Type Description Default <code>semantical_name</code> <code>str</code> <p>The semantic name to trigger the callback for</p> required <code>callback</code> <code>ActionCallback</code> <p>Function to call when traversing a node with this semantic name</p> required Source code in <code>src/katachi/schema/actions.py</code> <pre><code>def register_action(semantical_name: str, callback: ActionCallback) -&gt; None:\n    \"\"\"\n    Register a callback for a specific schema node semantic name.\n\n    Args:\n        semantical_name: The semantic name to trigger the callback for\n        callback: Function to call when traversing a node with this semantic name\n    \"\"\"\n    ActionRegistry.register(\n        semantical_name,\n        callback,\n        timing=ActionTiming.DURING_VALIDATION,\n        description=f\"Legacy action for {semantical_name}\",\n    )\n</code></pre>"},{"location":"modules/#schema-actions-katachischemaactions","title":"Schema Actions (<code>katachi.schema.actions</code>)","text":"<p>Register and execute actions to process files during schema traversal.</p> <pre><code>from katachi.schema.actions import register_action, NodeContext\nfrom pathlib import Path\nfrom typing import Any, list, dict\n\n# Define a custom action function\ndef process_image(\n    node: SchemaNode,\n    path: Path,\n    parent_contexts: list[NodeContext],\n    context: dict[str, Any]\n) -&gt; None:\n    \"\"\"Process an image file during schema traversal.\"\"\"\n    print(f\"Processing image: {path}\")\n\n    # Find parent timestamp directory\n    timestamp_path = None\n    for node, path in parent_contexts:\n        if node.semantical_name == \"timestamp\":\n            timestamp_path = path\n            break\n\n    if timestamp_path:\n        print(f\"Image from date: {timestamp_path.name}\")\n\n    # Use context data if provided\n    if \"target_dir\" in context:\n        target_path = context[\"target_dir\"] / path.name\n        print(f\"Would copy to: {target_path}\")\n\n# Register the action with a semantical name\nregister_action(\"image\", process_image)\n</code></pre> <p>Actions module for Katachi.</p> <p>This module provides functionality for registering and executing callbacks when traversing the file system according to a schema.</p>"},{"location":"modules/#katachi.schema.actions.ActionRegistration","title":"<code>ActionRegistration</code>  <code>dataclass</code>","text":"<p>Action registration details.</p> Source code in <code>src/katachi/schema/actions.py</code> <pre><code>@dataclass\nclass ActionRegistration:\n    \"\"\"Action registration details.\"\"\"\n\n    callback: ActionCallback\n    timing: ActionTiming\n    description: str\n</code></pre>"},{"location":"modules/#katachi.schema.actions.ActionRegistry","title":"<code>ActionRegistry</code>","text":"<p>Registry for file and directory actions.</p> Source code in <code>src/katachi/schema/actions.py</code> <pre><code>class ActionRegistry:\n    \"\"\"Registry for file and directory actions.\"\"\"\n\n    # Registry of callbacks by semantic name\n    _registry: ClassVar[dict[str, ActionRegistration]] = {}\n\n    @classmethod\n    def register(\n        cls,\n        semantical_name: str,\n        callback: ActionCallback,\n        timing: ActionTiming = ActionTiming.AFTER_VALIDATION,\n        description: str = \"\",\n    ) -&gt; None:\n        \"\"\"\n        Register a callback for a specific schema node semantic name.\n\n        Args:\n            semantical_name: The semantic name to trigger the callback for\n            callback: Function to call when traversing a node with this semantic name\n            timing: When the action should be executed\n            description: Human-readable description of what the action does\n        \"\"\"\n        cls._registry[semantical_name] = ActionRegistration(\n            callback=callback, timing=timing, description=description or f\"Action for {semantical_name}\"\n        )\n\n    @classmethod\n    def get(cls, semantical_name: str) -&gt; Optional[ActionRegistration]:\n        \"\"\"Get a registered action by semantical name.\"\"\"\n        return cls._registry.get(semantical_name)\n\n    @classmethod\n    def execute_actions(\n        cls,\n        registry: NodeRegistry,\n        context: Optional[dict[str, Any]] = None,\n        timing: ActionTiming = ActionTiming.AFTER_VALIDATION,\n    ) -&gt; list[ActionResult]:\n        \"\"\"\n        Execute all registered actions on validated nodes.\n\n        Args:\n            registry: Registry of validated nodes\n            context: Additional context data\n            timing: Which set of actions to execute based on timing\n\n        Returns:\n            List of action results\n        \"\"\"\n        results = []\n        context = context or {}\n\n        # Get all semantical names from the registry\n        for semantical_name, registration in cls._registry.items():\n            # Skip actions that don't match the requested timing\n            if registration.timing != timing:\n                continue\n\n            # Get all nodes with this semantical name\n            node_contexts = registry.get_nodes_by_name(semantical_name)\n            for node_ctx in node_contexts:\n                try:\n                    # Get parent contexts\n                    parent_contexts = []\n                    for parent_path in node_ctx.parent_paths:\n                        parent_node_ctx = registry.get_node_by_path(parent_path)\n                        if parent_node_ctx:\n                            parent_contexts.append((parent_node_ctx.node, parent_node_ctx.path))\n\n                    # Execute the action\n                    registration.callback(node_ctx.node, node_ctx.path, parent_contexts, context)\n                    results.append(\n                        ActionResult(\n                            success=True,\n                            message=f\"Executed {registration.description}\",\n                            path=node_ctx.path,\n                            action_name=semantical_name,\n                        )\n                    )\n                except Exception as e:\n                    results.append(\n                        ActionResult(\n                            success=False,\n                            message=f\"Action failed: {e!s}\",\n                            path=node_ctx.path,\n                            action_name=semantical_name,\n                        )\n                    )\n\n        return results\n</code></pre>"},{"location":"modules/#katachi.schema.actions.ActionRegistry.execute_actions","title":"<code>execute_actions(registry, context=None, timing=ActionTiming.AFTER_VALIDATION)</code>  <code>classmethod</code>","text":"<p>Execute all registered actions on validated nodes.</p> <p>Parameters:</p> Name Type Description Default <code>registry</code> <code>NodeRegistry</code> <p>Registry of validated nodes</p> required <code>context</code> <code>Optional[dict[str, Any]]</code> <p>Additional context data</p> <code>None</code> <code>timing</code> <code>ActionTiming</code> <p>Which set of actions to execute based on timing</p> <code>AFTER_VALIDATION</code> <p>Returns:</p> Type Description <code>list[ActionResult]</code> <p>List of action results</p> Source code in <code>src/katachi/schema/actions.py</code> <pre><code>@classmethod\ndef execute_actions(\n    cls,\n    registry: NodeRegistry,\n    context: Optional[dict[str, Any]] = None,\n    timing: ActionTiming = ActionTiming.AFTER_VALIDATION,\n) -&gt; list[ActionResult]:\n    \"\"\"\n    Execute all registered actions on validated nodes.\n\n    Args:\n        registry: Registry of validated nodes\n        context: Additional context data\n        timing: Which set of actions to execute based on timing\n\n    Returns:\n        List of action results\n    \"\"\"\n    results = []\n    context = context or {}\n\n    # Get all semantical names from the registry\n    for semantical_name, registration in cls._registry.items():\n        # Skip actions that don't match the requested timing\n        if registration.timing != timing:\n            continue\n\n        # Get all nodes with this semantical name\n        node_contexts = registry.get_nodes_by_name(semantical_name)\n        for node_ctx in node_contexts:\n            try:\n                # Get parent contexts\n                parent_contexts = []\n                for parent_path in node_ctx.parent_paths:\n                    parent_node_ctx = registry.get_node_by_path(parent_path)\n                    if parent_node_ctx:\n                        parent_contexts.append((parent_node_ctx.node, parent_node_ctx.path))\n\n                # Execute the action\n                registration.callback(node_ctx.node, node_ctx.path, parent_contexts, context)\n                results.append(\n                    ActionResult(\n                        success=True,\n                        message=f\"Executed {registration.description}\",\n                        path=node_ctx.path,\n                        action_name=semantical_name,\n                    )\n                )\n            except Exception as e:\n                results.append(\n                    ActionResult(\n                        success=False,\n                        message=f\"Action failed: {e!s}\",\n                        path=node_ctx.path,\n                        action_name=semantical_name,\n                    )\n                )\n\n    return results\n</code></pre>"},{"location":"modules/#katachi.schema.actions.ActionRegistry.get","title":"<code>get(semantical_name)</code>  <code>classmethod</code>","text":"<p>Get a registered action by semantical name.</p> Source code in <code>src/katachi/schema/actions.py</code> <pre><code>@classmethod\ndef get(cls, semantical_name: str) -&gt; Optional[ActionRegistration]:\n    \"\"\"Get a registered action by semantical name.\"\"\"\n    return cls._registry.get(semantical_name)\n</code></pre>"},{"location":"modules/#katachi.schema.actions.ActionRegistry.register","title":"<code>register(semantical_name, callback, timing=ActionTiming.AFTER_VALIDATION, description='')</code>  <code>classmethod</code>","text":"<p>Register a callback for a specific schema node semantic name.</p> <p>Parameters:</p> Name Type Description Default <code>semantical_name</code> <code>str</code> <p>The semantic name to trigger the callback for</p> required <code>callback</code> <code>ActionCallback</code> <p>Function to call when traversing a node with this semantic name</p> required <code>timing</code> <code>ActionTiming</code> <p>When the action should be executed</p> <code>AFTER_VALIDATION</code> <code>description</code> <code>str</code> <p>Human-readable description of what the action does</p> <code>''</code> Source code in <code>src/katachi/schema/actions.py</code> <pre><code>@classmethod\ndef register(\n    cls,\n    semantical_name: str,\n    callback: ActionCallback,\n    timing: ActionTiming = ActionTiming.AFTER_VALIDATION,\n    description: str = \"\",\n) -&gt; None:\n    \"\"\"\n    Register a callback for a specific schema node semantic name.\n\n    Args:\n        semantical_name: The semantic name to trigger the callback for\n        callback: Function to call when traversing a node with this semantic name\n        timing: When the action should be executed\n        description: Human-readable description of what the action does\n    \"\"\"\n    cls._registry[semantical_name] = ActionRegistration(\n        callback=callback, timing=timing, description=description or f\"Action for {semantical_name}\"\n    )\n</code></pre>"},{"location":"modules/#katachi.schema.actions.ActionResult","title":"<code>ActionResult</code>","text":"<p>Represents the result of an action execution.</p> Source code in <code>src/katachi/schema/actions.py</code> <pre><code>class ActionResult:\n    \"\"\"Represents the result of an action execution.\"\"\"\n\n    def __init__(self, success: bool, message: str, path: Path, action_name: str):\n        \"\"\"\n        Initialize an action result.\n\n        Args:\n            success: Whether the action succeeded\n            message: Description of what happened\n            path: The path the action was performed on\n            action_name: Name of the action that was performed\n        \"\"\"\n        self.success = success\n        self.message = message\n        self.path = path\n        self.action_name = action_name\n\n    def __str__(self) -&gt; str:\n        status = \"Success\" if self.success else \"Failed\"\n        return f\"{status} - {self.action_name} on {self.path}: {self.message}\"\n</code></pre>"},{"location":"modules/#katachi.schema.actions.ActionResult.__init__","title":"<code>__init__(success, message, path, action_name)</code>","text":"<p>Initialize an action result.</p> <p>Parameters:</p> Name Type Description Default <code>success</code> <code>bool</code> <p>Whether the action succeeded</p> required <code>message</code> <code>str</code> <p>Description of what happened</p> required <code>path</code> <code>Path</code> <p>The path the action was performed on</p> required <code>action_name</code> <code>str</code> <p>Name of the action that was performed</p> required Source code in <code>src/katachi/schema/actions.py</code> <pre><code>def __init__(self, success: bool, message: str, path: Path, action_name: str):\n    \"\"\"\n    Initialize an action result.\n\n    Args:\n        success: Whether the action succeeded\n        message: Description of what happened\n        path: The path the action was performed on\n        action_name: Name of the action that was performed\n    \"\"\"\n    self.success = success\n    self.message = message\n    self.path = path\n    self.action_name = action_name\n</code></pre>"},{"location":"modules/#katachi.schema.actions.ActionTiming","title":"<code>ActionTiming</code>","text":"<p>               Bases: <code>Enum</code></p> <p>When an action should be executed.</p> Source code in <code>src/katachi/schema/actions.py</code> <pre><code>class ActionTiming(Enum):\n    \"\"\"When an action should be executed.\"\"\"\n\n    DURING_VALIDATION = auto()  # Run during structure validation (old behavior)\n    AFTER_VALIDATION = auto()  # Run after all validation is complete (default new behavior)\n</code></pre>"},{"location":"modules/#katachi.schema.actions.process_node","title":"<code>process_node(node, path, parent_contexts, context=None)</code>","text":"<p>Process a node by running any registered callbacks for it.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>SchemaNode</code> <p>Current schema node being processed</p> required <code>path</code> <code>Path</code> <p>Path being validated</p> required <code>parent_contexts</code> <code>list[NodeContext]</code> <p>List of parent (node, path) tuples</p> required <code>context</code> <code>Optional[dict[str, Any]]</code> <p>Additional context data</p> <code>None</code> Source code in <code>src/katachi/schema/actions.py</code> <pre><code>def process_node(\n    node: SchemaNode,\n    path: Path,\n    parent_contexts: list[NodeContext],\n    context: Optional[dict[str, Any]] = None,\n) -&gt; None:\n    \"\"\"\n    Process a node by running any registered callbacks for it.\n\n    Args:\n        node: Current schema node being processed\n        path: Path being validated\n        parent_contexts: List of parent (node, path) tuples\n        context: Additional context data\n    \"\"\"\n    context = context or {}\n\n    # Check if there's a callback registered for this node's semantic name\n    registration = ActionRegistry.get(node.semantical_name)\n    if registration and registration.timing == ActionTiming.DURING_VALIDATION:\n        registration.callback(node, path, parent_contexts, context)\n</code></pre>"},{"location":"modules/#katachi.schema.actions.register_action","title":"<code>register_action(semantical_name, callback)</code>","text":"<p>Register a callback for a specific schema node semantic name.</p> <p>Parameters:</p> Name Type Description Default <code>semantical_name</code> <code>str</code> <p>The semantic name to trigger the callback for</p> required <code>callback</code> <code>ActionCallback</code> <p>Function to call when traversing a node with this semantic name</p> required Source code in <code>src/katachi/schema/actions.py</code> <pre><code>def register_action(semantical_name: str, callback: ActionCallback) -&gt; None:\n    \"\"\"\n    Register a callback for a specific schema node semantic name.\n\n    Args:\n        semantical_name: The semantic name to trigger the callback for\n        callback: Function to call when traversing a node with this semantic name\n    \"\"\"\n    ActionRegistry.register(\n        semantical_name,\n        callback,\n        timing=ActionTiming.DURING_VALIDATION,\n        description=f\"Legacy action for {semantical_name}\",\n    )\n</code></pre>"},{"location":"modules/#validation-registry-katachivalidationregistry","title":"Validation Registry (<code>katachi.validation.registry</code>)","text":"<p>Track and query validated nodes across the schema hierarchy.</p> <pre><code>from katachi.validation.registry import NodeRegistry\nfrom katachi.schema.schema_node import SchemaNode\nfrom pathlib import Path\n\n# Create a registry\nregistry = NodeRegistry()\n\n# Register nodes as they're validated\nregistry.register_node(schema_node, path, parent_paths)\n\n# Query nodes by semantical name\nimage_paths = registry.get_paths_by_name(\"image\")\n\n# Get all nodes under a specific directory\nnodes = list(registry.get_nodes_under_path(Path(\"data/01.01.2023\")))\n</code></pre> <p>Registry module for tracking validated nodes.</p> <p>This module provides functionality for registering and querying nodes that have passed validation, to support cross-level predicate evaluation.</p>"},{"location":"modules/#katachi.validation.registry.NodeContext","title":"<code>NodeContext</code>","text":"<p>Context information about a validated node.</p> Source code in <code>src/katachi/validation/registry.py</code> <pre><code>class NodeContext:\n    \"\"\"Context information about a validated node.\"\"\"\n\n    def __init__(self, node: SchemaNode, path: Path, parent_paths: Optional[list[Path]] = None):\n        \"\"\"\n        Initialize a node context.\n\n        Args:\n            node: The schema node\n            path: The path that was validated\n            parent_paths: List of parent paths in the hierarchy\n        \"\"\"\n        self.node = node\n        self.path = path\n        self.parent_paths = parent_paths or []\n\n    def __repr__(self) -&gt; str:\n        return f\"NodeContext({self.node.semantical_name}, {self.path})\"\n</code></pre>"},{"location":"modules/#katachi.validation.registry.NodeContext.__init__","title":"<code>__init__(node, path, parent_paths=None)</code>","text":"<p>Initialize a node context.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>SchemaNode</code> <p>The schema node</p> required <code>path</code> <code>Path</code> <p>The path that was validated</p> required <code>parent_paths</code> <code>Optional[list[Path]]</code> <p>List of parent paths in the hierarchy</p> <code>None</code> Source code in <code>src/katachi/validation/registry.py</code> <pre><code>def __init__(self, node: SchemaNode, path: Path, parent_paths: Optional[list[Path]] = None):\n    \"\"\"\n    Initialize a node context.\n\n    Args:\n        node: The schema node\n        path: The path that was validated\n        parent_paths: List of parent paths in the hierarchy\n    \"\"\"\n    self.node = node\n    self.path = path\n    self.parent_paths = parent_paths or []\n</code></pre>"},{"location":"modules/#katachi.validation.registry.NodeRegistry","title":"<code>NodeRegistry</code>","text":"<p>Registry for tracking nodes that passed validation.</p> Source code in <code>src/katachi/validation/registry.py</code> <pre><code>class NodeRegistry:\n    \"\"\"Registry for tracking nodes that passed validation.\"\"\"\n\n    def __init__(self) -&gt; None:\n        \"\"\"Initialize the node registry.\"\"\"\n        # Dictionary mapping semantical names to lists of node contexts\n        self._nodes_by_name: dict[str, list[NodeContext]] = {}\n        # Dictionary mapping paths to node contexts\n        self._nodes_by_path: dict[Path, NodeContext] = {}\n        # Set of directories that have been processed\n        self._processed_dirs: set[Path] = set()\n\n    def register_node(self, node: SchemaNode, path: Path, parent_paths: Optional[list[Path]] = None) -&gt; None:\n        \"\"\"\n        Register a node that passed validation.\n\n        Args:\n            node: Schema node that was validated\n            path: Path that was validated\n            parent_paths: List of parent paths in the hierarchy\n        \"\"\"\n        context = NodeContext(node, path, parent_paths)\n\n        # Register by semantical name\n        if node.semantical_name not in self._nodes_by_name:\n            self._nodes_by_name[node.semantical_name] = []\n        self._nodes_by_name[node.semantical_name].append(context)\n\n        # Register by path\n        self._nodes_by_path[path] = context\n\n    def register_processed_dir(self, dir_path: Path) -&gt; None:\n        \"\"\"\n        Register a directory as processed.\n\n        Args:\n            dir_path: Path to the processed directory\n        \"\"\"\n        self._processed_dirs.add(dir_path)\n\n    def is_dir_processed(self, dir_path: Path) -&gt; bool:\n        \"\"\"\n        Check if a directory has been processed.\n\n        Args:\n            dir_path: Path to check\n\n        Returns:\n            True if the directory has been processed, False otherwise\n        \"\"\"\n        return dir_path in self._processed_dirs\n\n    def get_nodes_by_name(self, semantical_name: str) -&gt; list[NodeContext]:\n        \"\"\"\n        Get all nodes with a given semantical name.\n\n        Args:\n            semantical_name: The semantical name to look up\n\n        Returns:\n            List of node contexts with the given semantical name\n        \"\"\"\n        return self._nodes_by_name.get(semantical_name, [])\n\n    def get_node_by_path(self, path: Path) -&gt; Optional[NodeContext]:\n        \"\"\"\n        Get a node by its path.\n\n        Args:\n            path: The path to look up\n\n        Returns:\n            Node context for the path, or None if not found\n        \"\"\"\n        return self._nodes_by_path.get(path)\n\n    def get_nodes_under_path(self, base_path: Path) -&gt; Iterator[NodeContext]:\n        \"\"\"\n        Get all nodes under a given path.\n\n        Args:\n            base_path: The base path to filter by\n\n        Returns:\n            Iterator of node contexts under the given path\n        \"\"\"\n        for path, context in self._nodes_by_path.items():\n            try:\n                if base_path in path.parents or path == base_path:\n                    yield context\n            except ValueError:\n                # This happens if paths are on different drives\n                continue\n\n    def get_paths_by_name(self, semantical_name: str) -&gt; list[Path]:\n        \"\"\"\n        Get all paths with a given semantical name.\n\n        Args:\n            semantical_name: The semantical name to look up\n\n        Returns:\n            List of paths with the given semantical name\n        \"\"\"\n        return [context.path for context in self.get_nodes_by_name(semantical_name)]\n\n    def clear(self) -&gt; None:\n        \"\"\"Clear the registry.\"\"\"\n        self._nodes_by_name.clear()\n        self._nodes_by_path.clear()\n        self._processed_dirs.clear()\n\n    def __str__(self) -&gt; str:\n        return f\"NodeRegistry with {len(self._nodes_by_path)} nodes of {len(self._nodes_by_name)} types\"\n</code></pre>"},{"location":"modules/#katachi.validation.registry.NodeRegistry.__init__","title":"<code>__init__()</code>","text":"<p>Initialize the node registry.</p> Source code in <code>src/katachi/validation/registry.py</code> <pre><code>def __init__(self) -&gt; None:\n    \"\"\"Initialize the node registry.\"\"\"\n    # Dictionary mapping semantical names to lists of node contexts\n    self._nodes_by_name: dict[str, list[NodeContext]] = {}\n    # Dictionary mapping paths to node contexts\n    self._nodes_by_path: dict[Path, NodeContext] = {}\n    # Set of directories that have been processed\n    self._processed_dirs: set[Path] = set()\n</code></pre>"},{"location":"modules/#katachi.validation.registry.NodeRegistry.clear","title":"<code>clear()</code>","text":"<p>Clear the registry.</p> Source code in <code>src/katachi/validation/registry.py</code> <pre><code>def clear(self) -&gt; None:\n    \"\"\"Clear the registry.\"\"\"\n    self._nodes_by_name.clear()\n    self._nodes_by_path.clear()\n    self._processed_dirs.clear()\n</code></pre>"},{"location":"modules/#katachi.validation.registry.NodeRegistry.get_node_by_path","title":"<code>get_node_by_path(path)</code>","text":"<p>Get a node by its path.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>Path</code> <p>The path to look up</p> required <p>Returns:</p> Type Description <code>Optional[NodeContext]</code> <p>Node context for the path, or None if not found</p> Source code in <code>src/katachi/validation/registry.py</code> <pre><code>def get_node_by_path(self, path: Path) -&gt; Optional[NodeContext]:\n    \"\"\"\n    Get a node by its path.\n\n    Args:\n        path: The path to look up\n\n    Returns:\n        Node context for the path, or None if not found\n    \"\"\"\n    return self._nodes_by_path.get(path)\n</code></pre>"},{"location":"modules/#katachi.validation.registry.NodeRegistry.get_nodes_by_name","title":"<code>get_nodes_by_name(semantical_name)</code>","text":"<p>Get all nodes with a given semantical name.</p> <p>Parameters:</p> Name Type Description Default <code>semantical_name</code> <code>str</code> <p>The semantical name to look up</p> required <p>Returns:</p> Type Description <code>list[NodeContext]</code> <p>List of node contexts with the given semantical name</p> Source code in <code>src/katachi/validation/registry.py</code> <pre><code>def get_nodes_by_name(self, semantical_name: str) -&gt; list[NodeContext]:\n    \"\"\"\n    Get all nodes with a given semantical name.\n\n    Args:\n        semantical_name: The semantical name to look up\n\n    Returns:\n        List of node contexts with the given semantical name\n    \"\"\"\n    return self._nodes_by_name.get(semantical_name, [])\n</code></pre>"},{"location":"modules/#katachi.validation.registry.NodeRegistry.get_nodes_under_path","title":"<code>get_nodes_under_path(base_path)</code>","text":"<p>Get all nodes under a given path.</p> <p>Parameters:</p> Name Type Description Default <code>base_path</code> <code>Path</code> <p>The base path to filter by</p> required <p>Returns:</p> Type Description <code>Iterator[NodeContext]</code> <p>Iterator of node contexts under the given path</p> Source code in <code>src/katachi/validation/registry.py</code> <pre><code>def get_nodes_under_path(self, base_path: Path) -&gt; Iterator[NodeContext]:\n    \"\"\"\n    Get all nodes under a given path.\n\n    Args:\n        base_path: The base path to filter by\n\n    Returns:\n        Iterator of node contexts under the given path\n    \"\"\"\n    for path, context in self._nodes_by_path.items():\n        try:\n            if base_path in path.parents or path == base_path:\n                yield context\n        except ValueError:\n            # This happens if paths are on different drives\n            continue\n</code></pre>"},{"location":"modules/#katachi.validation.registry.NodeRegistry.get_paths_by_name","title":"<code>get_paths_by_name(semantical_name)</code>","text":"<p>Get all paths with a given semantical name.</p> <p>Parameters:</p> Name Type Description Default <code>semantical_name</code> <code>str</code> <p>The semantical name to look up</p> required <p>Returns:</p> Type Description <code>list[Path]</code> <p>List of paths with the given semantical name</p> Source code in <code>src/katachi/validation/registry.py</code> <pre><code>def get_paths_by_name(self, semantical_name: str) -&gt; list[Path]:\n    \"\"\"\n    Get all paths with a given semantical name.\n\n    Args:\n        semantical_name: The semantical name to look up\n\n    Returns:\n        List of paths with the given semantical name\n    \"\"\"\n    return [context.path for context in self.get_nodes_by_name(semantical_name)]\n</code></pre>"},{"location":"modules/#katachi.validation.registry.NodeRegistry.is_dir_processed","title":"<code>is_dir_processed(dir_path)</code>","text":"<p>Check if a directory has been processed.</p> <p>Parameters:</p> Name Type Description Default <code>dir_path</code> <code>Path</code> <p>Path to check</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the directory has been processed, False otherwise</p> Source code in <code>src/katachi/validation/registry.py</code> <pre><code>def is_dir_processed(self, dir_path: Path) -&gt; bool:\n    \"\"\"\n    Check if a directory has been processed.\n\n    Args:\n        dir_path: Path to check\n\n    Returns:\n        True if the directory has been processed, False otherwise\n    \"\"\"\n    return dir_path in self._processed_dirs\n</code></pre>"},{"location":"modules/#katachi.validation.registry.NodeRegistry.register_node","title":"<code>register_node(node, path, parent_paths=None)</code>","text":"<p>Register a node that passed validation.</p> <p>Parameters:</p> Name Type Description Default <code>node</code> <code>SchemaNode</code> <p>Schema node that was validated</p> required <code>path</code> <code>Path</code> <p>Path that was validated</p> required <code>parent_paths</code> <code>Optional[list[Path]]</code> <p>List of parent paths in the hierarchy</p> <code>None</code> Source code in <code>src/katachi/validation/registry.py</code> <pre><code>def register_node(self, node: SchemaNode, path: Path, parent_paths: Optional[list[Path]] = None) -&gt; None:\n    \"\"\"\n    Register a node that passed validation.\n\n    Args:\n        node: Schema node that was validated\n        path: Path that was validated\n        parent_paths: List of parent paths in the hierarchy\n    \"\"\"\n    context = NodeContext(node, path, parent_paths)\n\n    # Register by semantical name\n    if node.semantical_name not in self._nodes_by_name:\n        self._nodes_by_name[node.semantical_name] = []\n    self._nodes_by_name[node.semantical_name].append(context)\n\n    # Register by path\n    self._nodes_by_path[path] = context\n</code></pre>"},{"location":"modules/#katachi.validation.registry.NodeRegistry.register_processed_dir","title":"<code>register_processed_dir(dir_path)</code>","text":"<p>Register a directory as processed.</p> <p>Parameters:</p> Name Type Description Default <code>dir_path</code> <code>Path</code> <p>Path to the processed directory</p> required Source code in <code>src/katachi/validation/registry.py</code> <pre><code>def register_processed_dir(self, dir_path: Path) -&gt; None:\n    \"\"\"\n    Register a directory as processed.\n\n    Args:\n        dir_path: Path to the processed directory\n    \"\"\"\n    self._processed_dirs.add(dir_path)\n</code></pre>"},{"location":"modules/#validation-core-katachivalidationcore","title":"Validation Core (<code>katachi.validation.core</code>)","text":"<p>Core validation components for creating custom validators.</p> <pre><code>from katachi.validation.core import ValidationResult, ValidationReport, ValidatorRegistry\nfrom katachi.schema.schema_node import SchemaNode\nfrom pathlib import Path\n\n# Define a custom validator\ndef image_dimensions_validator(node: SchemaNode, path: Path):\n    \"\"\"Check if image dimensions meet requirements.\"\"\"\n    from PIL import Image\n\n    try:\n        with Image.open(path) as img:\n            width, height = img.size\n\n            # Check if size meets requirements\n            min_width = node.metadata.get(\"min_width\", 0)\n            min_height = node.metadata.get(\"min_height\", 0)\n\n            if width &lt; min_width:\n                return ValidationResult(\n                    is_valid=False,\n                    message=f\"Image width ({width}px) is less than minimum ({min_width}px)\",\n                    path=path,\n                    validator_name=\"image_dimensions\"\n                )\n\n            if height &lt; min_height:\n                return ValidationResult(\n                    is_valid=False,\n                    message=f\"Image height ({height}px) is less than minimum ({min_height}px)\",\n                    path=path,\n                    validator_name=\"image_dimensions\"\n                )\n\n            return ValidationResult(\n                is_valid=True,\n                message=\"Image dimensions are valid\",\n                path=path,\n                validator_name=\"image_dimensions\"\n            )\n    except:\n        return ValidationResult(\n            is_valid=False,\n            message=\"Failed to open image file\",\n            path=path,\n            validator_name=\"image_dimensions\"\n        )\n\n# Register the custom validator\nValidatorRegistry.register(\"image_dimensions\", image_dimensions_validator)\n</code></pre>"},{"location":"modules/#katachi.validation.core.ValidationReport","title":"<code>ValidationReport</code>","text":"<p>Collection of validation results with formatted output.</p> Source code in <code>src/katachi/validation/core.py</code> <pre><code>class ValidationReport:\n    \"\"\"Collection of validation results with formatted output.\"\"\"\n\n    def __init__(self) -&gt; None:\n        self.results: list[ValidationResult] = []\n        self.context: dict[str, Any] = {}\n\n    def add_result(self, result: ValidationResult) -&gt; None:\n        self.results.append(result)\n\n    def add_results(self, results: list[ValidationResult]) -&gt; None:\n        self.results.extend(results)\n\n    def is_valid(self) -&gt; bool:\n        return all(result.is_valid for result in self.results)\n\n    def format_report(self) -&gt; str:\n        \"\"\"Format validation results into human-readable output.\"\"\"\n        if self.is_valid():\n            return \"All validations passed successfully!\"\n\n        failures = [r for r in self.results if not r.is_valid]\n        report_lines = [\"Validation failed with the following issues:\"]\n\n        for failure in failures:\n            report_lines.append(f\"\u274c {failure.path}: {failure.message}\")\n\n        return \"\\n\".join(report_lines)\n</code></pre>"},{"location":"modules/#katachi.validation.core.ValidationReport.format_report","title":"<code>format_report()</code>","text":"<p>Format validation results into human-readable output.</p> Source code in <code>src/katachi/validation/core.py</code> <pre><code>def format_report(self) -&gt; str:\n    \"\"\"Format validation results into human-readable output.\"\"\"\n    if self.is_valid():\n        return \"All validations passed successfully!\"\n\n    failures = [r for r in self.results if not r.is_valid]\n    report_lines = [\"Validation failed with the following issues:\"]\n\n    for failure in failures:\n        report_lines.append(f\"\u274c {failure.path}: {failure.message}\")\n\n    return \"\\n\".join(report_lines)\n</code></pre>"},{"location":"modules/#katachi.validation.core.ValidationResult","title":"<code>ValidationResult</code>  <code>dataclass</code>","text":"<p>Result of a validation check with detailed information.</p> Source code in <code>src/katachi/validation/core.py</code> <pre><code>@dataclass\nclass ValidationResult:\n    \"\"\"Result of a validation check with detailed information.\"\"\"\n\n    is_valid: bool\n    message: str\n    path: Path\n    validator_name: str\n    context: Optional[dict[str, Any]] = None\n\n    def __bool__(self) -&gt; bool:\n        \"\"\"Allow using validation result in boolean contexts.\"\"\"\n        return self.is_valid\n</code></pre>"},{"location":"modules/#katachi.validation.core.ValidationResult.__bool__","title":"<code>__bool__()</code>","text":"<p>Allow using validation result in boolean contexts.</p> Source code in <code>src/katachi/validation/core.py</code> <pre><code>def __bool__(self) -&gt; bool:\n    \"\"\"Allow using validation result in boolean contexts.\"\"\"\n    return self.is_valid\n</code></pre>"},{"location":"modules/#katachi.validation.core.ValidatorRegistry","title":"<code>ValidatorRegistry</code>","text":"<p>Registry for custom validators.</p> Source code in <code>src/katachi/validation/core.py</code> <pre><code>class ValidatorRegistry:\n    \"\"\"Registry for custom validators.\"\"\"\n\n    # Dictionary of validator functions by name\n    _validators: ClassVar[dict[str, Callable]] = {}\n\n    @classmethod\n    def register(cls, name: str, validator_func: Callable) -&gt; None:\n        \"\"\"Register a new validator function.\"\"\"\n        cls._validators[name] = validator_func\n\n    @classmethod\n    def get_validator(cls, name: str) -&gt; Optional[Callable]:\n        \"\"\"Get a registered validator function by name.\"\"\"\n        return cls._validators.get(name)\n\n    @classmethod\n    def run_validators(cls, node: SchemaNode, path: Path) -&gt; list[ValidationResult]:\n        \"\"\"Run all registered validators for a given node and path.\"\"\"\n        results = []\n\n        for name, validator_func in cls._validators.items():\n            try:\n                result = validator_func(node, path)\n                if isinstance(result, ValidationResult):\n                    results.append(result)\n                elif isinstance(result, list):\n                    results.extend([r for r in result if isinstance(r, ValidationResult)])\n            except Exception as e:\n                # Ensure validator failures don't crash the entire validation\n                results.append(\n                    ValidationResult(\n                        is_valid=False,\n                        message=f\"Validator '{name}' failed with error: {e!s}\",\n                        path=path,\n                        validator_name=name,\n                    )\n                )\n\n        return results\n</code></pre>"},{"location":"modules/#katachi.validation.core.ValidatorRegistry.get_validator","title":"<code>get_validator(name)</code>  <code>classmethod</code>","text":"<p>Get a registered validator function by name.</p> Source code in <code>src/katachi/validation/core.py</code> <pre><code>@classmethod\ndef get_validator(cls, name: str) -&gt; Optional[Callable]:\n    \"\"\"Get a registered validator function by name.\"\"\"\n    return cls._validators.get(name)\n</code></pre>"},{"location":"modules/#katachi.validation.core.ValidatorRegistry.register","title":"<code>register(name, validator_func)</code>  <code>classmethod</code>","text":"<p>Register a new validator function.</p> Source code in <code>src/katachi/validation/core.py</code> <pre><code>@classmethod\ndef register(cls, name: str, validator_func: Callable) -&gt; None:\n    \"\"\"Register a new validator function.\"\"\"\n    cls._validators[name] = validator_func\n</code></pre>"},{"location":"modules/#katachi.validation.core.ValidatorRegistry.run_validators","title":"<code>run_validators(node, path)</code>  <code>classmethod</code>","text":"<p>Run all registered validators for a given node and path.</p> Source code in <code>src/katachi/validation/core.py</code> <pre><code>@classmethod\ndef run_validators(cls, node: SchemaNode, path: Path) -&gt; list[ValidationResult]:\n    \"\"\"Run all registered validators for a given node and path.\"\"\"\n    results = []\n\n    for name, validator_func in cls._validators.items():\n        try:\n            result = validator_func(node, path)\n            if isinstance(result, ValidationResult):\n                results.append(result)\n            elif isinstance(result, list):\n                results.extend([r for r in result if isinstance(r, ValidationResult)])\n        except Exception as e:\n            # Ensure validator failures don't crash the entire validation\n            results.append(\n                ValidationResult(\n                    is_valid=False,\n                    message=f\"Validator '{name}' failed with error: {e!s}\",\n                    path=path,\n                    validator_name=name,\n                )\n            )\n\n    return results\n</code></pre>"},{"location":"modules/#command-line-interface-katachicli","title":"Command Line Interface (<code>katachi.cli</code>)","text":"<p>Katachi provides a convenient command-line interface for validating directory structures.</p> <pre><code># Basic validation\nkatachi validate schema.yaml target_directory\n\n# Detailed reporting\nkatachi validate schema.yaml target_directory --detail-report\n\n# Execute actions during validation\nkatachi validate schema.yaml target_directory --execute-actions\n\n# Provide custom context for actions\nkatachi validate schema.yaml target_directory --execute-actions --context '{\"target_dir\": \"output\"}'\n</code></pre>"},{"location":"modules/#katachi.cli.describe","title":"<code>describe(schema_path, target_path)</code>","text":"<p>Describes the schema of a directory structure.</p> <p>Parameters:</p> Name Type Description Default <code>schema_path</code> <code>Path</code> <p>Path to the schema.yaml file</p> required <code>target_path</code> <code>Path</code> <p>Path to the directory to describe</p> required <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>src/katachi/cli.py</code> <pre><code>@app.command()\ndef describe(schema_path: Path, target_path: Path) -&gt; None:\n    \"\"\"\n    Describes the schema of a directory structure.\n\n    Args:\n        schema_path: Path to the schema.yaml file\n        target_path: Path to the directory to describe\n\n    Returns:\n        None\n    \"\"\"\n    console.print(f\"Describing schema [bold cyan]{schema_path}[/] for directory [bold cyan]{target_path}[/]\")\n\n    try:\n        # Load the schema\n        schema = load_yaml(schema_path, target_path)\n        console.print(Panel(str(schema), title=\"Schema Description\", border_style=\"blue\", expand=False))\n    except Exception as e:\n        console.print(Panel(f\"Failed to describe schema: {e!s}\", title=\"Error\", border_style=\"red\", expand=False))\n</code></pre>"},{"location":"modules/#katachi.cli.validate","title":"<code>validate(schema_path, target_path, detail_report=typer.Option(False, '--detail-report', help='Show detailed validation report'), execute_actions=typer.Option(False, '--execute-actions', help='Execute actions during/after validation'), context_json=typer.Option(None, '--context', help='JSON string with context data for actions'))</code>","text":"<p>Validates a directory structure against a schema.yaml file.</p> <p>Parameters:</p> Name Type Description Default <code>schema_path</code> <code>Path</code> <p>Path to the schema.yaml file</p> required <code>target_path</code> <code>Path</code> <p>Path to the directory to validate</p> required <code>detail_report</code> <code>bool</code> <p>Whether to show a detailed validation report</p> <code>Option(False, '--detail-report', help='Show detailed validation report')</code> <code>execute_actions</code> <code>bool</code> <p>Whether to execute registered actions</p> <code>Option(False, '--execute-actions', help='Execute actions during/after validation')</code> <code>context_json</code> <code>str</code> <p>JSON string with context data for actions</p> <code>Option(None, '--context', help='JSON string with context data for actions')</code> <p>Returns:</p> Type Description <code>None</code> <p>None</p> Source code in <code>src/katachi/cli.py</code> <pre><code>@app.command()\ndef validate(\n    schema_path: Path,\n    target_path: Path,\n    detail_report: bool = typer.Option(False, \"--detail-report\", help=\"Show detailed validation report\"),\n    execute_actions: bool = typer.Option(False, \"--execute-actions\", help=\"Execute actions during/after validation\"),\n    context_json: str = typer.Option(None, \"--context\", help=\"JSON string with context data for actions\"),\n) -&gt; None:\n    \"\"\"\n    Validates a directory structure against a schema.yaml file.\n\n    Args:\n        schema_path: Path to the schema.yaml file\n        target_path: Path to the directory to validate\n        detail_report: Whether to show a detailed validation report\n        execute_actions: Whether to execute registered actions\n        context_json: JSON string with context data for actions\n\n    Returns:\n        None\n    \"\"\"\n    console.print(f\"Validating schema [bold cyan]{schema_path}[/] against directory [bold cyan]{target_path}[/]\")\n\n    # Load the schema\n    schema = _load_schema(schema_path, target_path)\n    if schema is None:\n        console.print(Panel(\"Failed to load schema!\", title=\"Error\", border_style=\"red\", expand=False))\n        return\n\n    # Parse context JSON if provided\n    context = None\n    if context_json:\n        try:\n            import json\n\n            context = json.loads(context_json)\n        except json.JSONDecodeError:\n            console.print(Panel(\"Invalid JSON in context parameter\", title=\"Error\", border_style=\"red\", expand=False))\n            return\n\n    # Validate the directory structure against the schema\n    validation_report = SchemaValidator.validate_schema(\n        schema, target_path, execute_actions=execute_actions, context=context\n    )\n\n    # Display the results\n    _display_validation_results(validation_report, detail_report)\n\n    # Exit with error code if validation failed\n    if not validation_report.is_valid():\n        return\n</code></pre>"},{"location":"modules/#extending-katachi","title":"Extending Katachi","text":""},{"location":"modules/#custom-validators","title":"Custom Validators","text":"<p>You can extend Katachi with custom validators to handle specific validation requirements.</p> <pre><code>from pathlib import Path\nfrom katachi.schema.schema_node import SchemaNode\nfrom katachi.validation.core import ValidationResult, ValidatorRegistry\n\n# Define a custom validator\ndef file_content_validator(node: SchemaNode, path: Path):\n    \"\"\"Check file content against a pattern.\"\"\"\n    import re\n\n    # Only apply to files with content_pattern in metadata\n    if not node.metadata.get(\"content_pattern\"):\n        return []\n\n    # Read file content\n    try:\n        with open(path, \"r\") as f:\n            content = f.read()\n\n        # Validate against pattern\n        pattern = re.compile(node.metadata[\"content_pattern\"])\n        if pattern.search(content):\n            return ValidationResult(\n                is_valid=True,\n                message=\"File content matches pattern\",\n                path=path,\n                validator_name=\"content_pattern\"\n            )\n        else:\n            return ValidationResult(\n                is_valid=False,\n                message=f\"File content doesn't match pattern: {node.metadata['content_pattern']}\",\n                path=path,\n                validator_name=\"content_pattern\"\n            )\n    except Exception as e:\n        return ValidationResult(\n            is_valid=False,\n            message=f\"Error validating file content: {str(e)}\",\n            path=path,\n            validator_name=\"content_pattern\"\n        )\n\n# Register the validator\nValidatorRegistry.register(\"content_pattern\", file_content_validator)\n</code></pre>"},{"location":"modules/#custom-predicates","title":"Custom Predicates","text":"<p>The predicate system can be extended with new types of relationship validation.</p> <p>Types of predicates currently supported:</p> Predicate Type Description <code>pair_comparison</code> Ensures files with the same base names exist across different element types <p>To implement other predicate types, extend the <code>validate_predicate</code> method in the <code>SchemaValidator</code> class.</p>"}]}